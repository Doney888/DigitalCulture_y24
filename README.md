# DigitalCulture_y24
Digital culture course solutions (y24 version)
**УБЕДИТЕЛЬНАЯ ПРОСЬБА**: используйте данных репозиторий только как подсказки к решению, если вы застряли на каком-то этапе, ни в коем случае не выдавайте данные решения за свои. Автор не поддерживает списывание

## Лабораторная работа 1: Работа в терминале

### Задание 1:
- **Условие**: Запустите Bash-скрипт и напишите, что выведется на экран.
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/Task1/run-me.sh)
- **Решение**: `./run-me.sh`

### Задание 2: 
- **Условие**: Найдите в архиве файл с правами на исполнение. Выведите его название.
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/Task2/find-exe.tar.gz)
- **Решение**: [ссылка на файл с решением задания](./Lab1/Task2/script.sh)

### Задание 3: 
- **Условие**: Посчитайте суммарное количество слов во всех файлах, имена которых содержат слово, указанное в файле target.word.
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/Task3/task/word-count.zip)
- **Решение**: [ссылка на файл с решением задания](./Lab1/Task3/task/script.sh)

### Задание 4: 
- **Условие**: Отсортируйте файлы в директории по возрастанию времени модификации. Посчитайте шестнадцатеричный SHA-256 хеш конкатенации данных этих файлов в этом порядке (без каких-либо дополнительных символов).
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/Task4/mod-sort.zip)
- **Решение**: [ссылка на файл с решением задания](./Lab1/script.sh)

### Задание 5: 
- **Условие**: 
В операционных системах семейства GNU/Linux обычно доступна специальная файловая система procfs, в которой данные о процессах представлены в виде файлов. Обычно она доступна в директории /proc.

Попробуйте зайти в неё и изучить содержимое. Каждая директория с числовым названием означает процесс с соответствующим PID. Внутри можно найти разную информацию о процессе — статистику его работы, информацию об исполняемом файле, текущей директории.

Среди них есть файл environ — в нём хранятся переменные окружения. Их используют для конфигурирования запуска или работы приложений. Нередко с их помощью передают и какие-то секреты для запуска приложения.

Вам дан архив, в котором находятся только файлы environ для каждого запущенного в системе процесса. Напишите скрипт, который найдёт лексикографически минимальное значение переменной TASK.
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/Task5/188f62129beb58ff.zip)
- **Решение**: [ссылка на файл с решением задания](./Lab1/Task5/script.sh)

### Задание 6: 
- **Условие**: Посчитайте количество телефонных номеров в формате E.164 в данном файле. Номера могут начинаться или не начинаться со знака «+», не могут начинаться с 0 (в том числе после знака «+») и содержат от 2 до 15 цифр.

В рамках данного задания номера не могут содержать пробелы (например, +7 812 607 04 74 это три разных номера), и при этом они отделены от любых других символов хотя бы одним пробельным символом с обеих сторон. Например, в строке «(номер: +78126070474)» номера нет.

Указание: используйте регулярные выражения. 
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/Task6/phone-numbers)
- **Решение**: [ссылка на файл с решением задания](./Lab1/Task6/script.sh)

### Задание 7: 
- **Условие**: [Скачайте все файлы по указанным ссылкам. Посчитайте суммарный размер PDF-документов среди скачанных файлов в байтах. Это задача с подвохом.]
- **Файл с условием**: [ссылка на файл с условием задания](./Lab1/wget-pdsf)
- **Решение**: [ссылка на файл с решением задания](./Lab1/script7.sh)

---

## Лабораторная работа 2: Система контроля версий

### Задание 1: [master]
- **Условие**:
Первое задание - запушить коммиты которые создались когда вы написали `git start`.

Просто запустите `git verify` после того как вы начали первое задание и гордитесь что вы его выполнили :)
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task1_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task1_solution.md)

### Задание 2: [commit-one-file-staged]
- **Условие**:
  Сейчас в корне проекта есть два файла - `A.txt` и `B.txt`. Они оба были застейджены (staged for commit).
Цель - закоммитить только один из них.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 3: [ignore-them]
- **Условие**: Зачастую бывает полезно сказать гиту, за какими файлами нужно следить, а за какими нет. Разработчики почти всегда не хотят включать в историю своего проекта сгенерированные файлы, скомпилированный код или библиотеки.
Ваша задача настроить ваш репозиторий таким образом, чтобы игнорировались:
 * все файлы с расширением `exe`
 * все файлы с расширением `o`
 * все файлы с расширением `jar`
 * вся директория `libraries`
Примеры файлов уже были сгенерированы.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 4: [merge-conflict]
- **Условие**: Merge-конфликт возникает когда вы изменяете одну и ту же часть одного и того же файла по-разному
в двух ветках которые вы пытаетесь смерджить

Разработчик должен разрешать конфликты вручную.

Сейчас ваш репозиторий выглядит так:

            HEAD
             |
        merge-conflict
             |
    A <----- B
     \
      \----- C
             |
    another-piece-of-work
         
Вам нужно смерджить `another-piece-of-work` в вашу текущую ветку. 
Это создаст конфликт который вам нужно разрешить.
В конце ваш репозиторий должен выглядеть так:

                     HEAD
                      |
                 merge-conflict
                      |
    A <----- B <----- D
     \               /
      \----- C <----/
             |
    another-piece-of-work
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 5: [save-your-work]
- **Условие**: Представим ситуацию: дома вы сделали домашки по курсу "Введение в программирование": "Подсчёт слов" 
а затем домашку "Свой сканнер". Первую вы закоммитили, а вторую не доделали и не закоммитили. Вы 
приходите на пару и собираетесь записываться в очередь, как вдруг замечаете что в подсчёте слов 
сделали багу за которую вам поставят три минуса. Вам нужно быстро исправить багу и сдать домашку 
"Подсчёт слов", но текущее состояние вашего репозитория с незакоммиченными изменениями вы коммитить не хотите.

Только сейчас ситуация учебная, а не игра на баллы, поэтому вместо домашки "Подсчёт слов" у вас файл bug.txt.

Гит позволяет вам сохранить вашу работу *на стороне* и продолжить её позже. Найдите подходящий инструмент Гита и
используйте его чтобы решить ситуацию.

Ищите багу в `bug.txt`.

После того как вы закоммитили исправление баги, вернитесь к своей работе. Закончите её добавив новую строку в `bug.txt` следующего содержания:

    `Finally, finished it!`

Затем, закоммитите свою работу после исправления баги.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 6: [change-branch-history]
- **Условие**: Вы работали над обычной задачей, когда ваш босс пришел и сказал вам исправить недавний баг в приложении. Поскольку ваша
работа над задачей еще не была завершена, вы решили откатиться туда, откуда начали, и исправить баг там.

Ваш репозиторий выглядит так:

            HEAD
             |
    change-branch-history
             |
    A <----- B
     \
      \----- C
             |
         hot-bugfix
         
Теперь вы поняли, что баг вас сильно донимает, и вы не хотите продолжать свою работу без этого исправления. 
Вы хотите, чтобы ваша история выглядела так:

                     HEAD
                      |
             change-branch-history
                      |
    A <----- C <----- B
             |
         hot-bugfix

Как это сделать?
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 7: [forge-date]
- **Условие**: Вы должны были сделать домашку ещё неделю назад. Однако у вас были более
важные дела, поэтому вы сделали коммит только что.

Как эксперт по git, измените дату последнего коммита. Не стесняйтесь -
сделайте так, чтобы казалось, что он был сделан в 1987 году!

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 8: [fix-old-typo]
- **Условие**: Пока вы работали, вы заметили опечатку в `file.txt` - вы написали `wordl` вместо `world`.

К сожалению, вы сделали еще один коммит поверх опечатки, поэтому сделать `git commit --amend` недостаточно.

Исправьте опечатку, исправив коммит в истории. Так же обратите внимание на сообщение коммита.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 9: [commit-lost]
- **Условие**: Вы создали коммит с очень важными изменениями. Затем вы захотели что-то исправить в этом коммите, поэтому вы сделали ammend-коммит. После этого вы поняли, что случайно затерли важный кусок кода когда сделали ammend.

Как вам известно, `git commit --amend` затирает предыдущий коммит, поэтому вы не можете просто отменить его, так же как и не можете найти его в истории коммитов.

Ваша задача - найти первый коммит. Он же точно должен быть где-то..

После того как вы его найдете, поставьте на него ветку `commit-lost` и проверьте ваше решение с помощью `git verify`

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 10: [too-many-commits]
- **Условие**: Вы работали над задачей и создали два коммита, внесли очень маленькие изменения. Вы не хотите испортить историю своего проекта, поэтому вы хотите сделать только один коммит, который содержит изменения, сделанные в последние два.

Напишите `git log -2`, чтобы увидеть последние два коммита.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 11: [executable]
- **Условие**: Вы создали простой bash-скрипт в `script.sh`. Однако, когда вы проверяете его
в Unix, у него нет необходимых разрешений на выполнение, поэтому вы не можете запустить его с помощью
`./script.sh` без выполнения `chmod +x script.sh` заранее.

Исправьте это, добавив бит исполняемого файла для `script.sh` в историю Git.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 12: [commit-parts]
- **Условие**: Вы долгое время работаете над задачей и замечаете, что сделали слишком много. Вы хотите, чтобы ваша работа была
закоммичена в двух разных коммитах, а не одним.

К сожалению, ваши изменения касаются только одного файла, поэтому невозможно просто сделать `git add` разных файлов по отдельности.

Закоммитьте все новые строки, которые содержат фразу "Task 1" в первом коммите, а остальные во втором.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 13: [invalid-order]
- **Условие**: Вы сделали два коммита, но вам не нравится порядок, в котором они появляются в истории. Поменяйте его.

Чтобы показать коммиты, которые нужно поменять, выполните команду `git log -2`.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 14: [search-improved]
- **Условие**: В вашем репозитории содержится текстовый файл `cool-cheatsheet.txt` с полезными bash-командами.
Недавно обнаружилось, что кто-то из коллег в него дописал cтроку, после ввода которой компьютер может намертво зависнуть.

К счастью, у вас уже есть программа `faulty-check`, которая проводит исчерпывающие тесты. При запуске она возвращает код 0, если текстовый файл безопасен, и 1 иначе.

Вам нужно выяснить, в каком именно коммите появилась проблемная команда.

## Указания
 * Не нужно перебирать все коммиты, в Git есть поддержка бинарного поиска.
 * Ревизия с тегом `1.0` гарантированно не вызывает зависаний.
 * Найдя искомый коммит, проверить решение можно при помощи следующей команды
 
        git push origin COMMIT_ID:search-improved
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

---

## Лабораторная работа 3: Система вёрстки TeX

- **Условие**: Вам дан PDF-файл. Создайте максимально точную его копию с помощью языка TeX.

Используйте этот шаблон — он же использован для генерации задания.

Требования к решению:

    Ваш файл будет скомпилирован с помощью PDFLaTeX.
    Задание будет не зачтено, если произойдёт ошибка компиляции. Предупреждения (warnings) допустимы.
    Весь код должен быть в одном файле.
    Подключение любых пакетов, кроме включенных в шаблон, запрещено.
    Не выравнивайте контент с помощью пробелов, не используйте горизонтальные или вертикальные ручные отступы (проверяется на уровне бан-листа)
    Вы можете определять свои команды, символы и другие конструкции.
    Вы не можете использовать \input, \include, а также любые команды, связанные с \write18
    Дедлайн — 15 октября 2024 года 01:23 МСК
    Сданные вовремя решения будут проверены в течение недели после дедлайна, после чего вы сможете их исправить и вернуть на допроверку
    Первый дополнительный дедлайн — 13 ноября 2024 года 01:23 МСК
    Второй дополнительный дедлайн — 6 декабря 2024 года 23:59 МСК
    На сдачи после второго дополнительного дедлайна будут начислены штрафные дни

Рекомендуем использовать Overleaf для решения задания. Если ваше решение собирается там с настройками по умолчанию, то и у нас оно соберётся.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

---

## Лабораторная работа 4: Компьютерные сети

- Для решения этого задания вам понадобится OpenVPN. Если у вас Windows, скачайте его с официального сайта. Если у вас Linux, найдите его в вашем пакетном менеджере. Если у вас Mac OS, скачайте Tunnelblick и установите расширение. На мобильных устройствах этот VPN не работает. Важно: OpenVPN Connect — это другое приложение. Оно не работает с нашим сервером.

Подключитесь к серверу. Вот ваш конфигурационный файл:

    config.ovpn

В каждом задании вам необходимо получить секрет — некую строку вида {abcdef123}. Её нужно сдать без фигурных скобок. Дополнительно, в заданиях HTTP и TCP приложите код вашего решения. В последнем вопросе кратко опишите ход решения заданий Curl, UDP и DNS. 

### Задание 1: [Curl]
- **Условие**: Сделайте с помощью утилиты curl запрос на http://10.8.0.1:8080/4959dc9c9862 с методом PATCH, передав query-параметр do со значением ed07a388dcbf, заголовок X-Access-Token со значением 890d749d45d5 и JSON-объект с единственным полем text со значением bb03bf3577fe в теле запроса. 
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task1_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task1_solution.md)

### Задание 2: [HTTP]
- **Условие**: Откройте в браузере http://10.8.0.1/. Чтобы получить секрет, нажмите кнопку на этой странице 10 000 раз. Автоматизируйте этот процесс. 
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 3: [TCP]
- **Условие**: Установите TCP соединение с хостом 10.8.0.1 на порт 1234. Выполните предлагаемое задание. При подключении к серверу вам даётся ограниченное время (60 секунд) на решение большого количества примеров. Руками такое решать сложно,поэтому автоматизируем процесс.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 4: [DNS]
- **Условие**: Узнайте TXT-запись домена 9ded6ab488dc.digital-culture-networking.melnikov.ch
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 5: [UDP]
- **Условие**: Хост 10.8.0.1 раз в 10 секунд проверяет, отвечает ли хост 10.8.0.214 на пинги (запросы ICMP Echo Request), и отправляет UDP-датаграмму ему на порт 666, если да. Добавьте этот адрес к своему VPN-интерфейсу и получите датаграмму. 
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

---

## Лабораторная работа 5: Отладка и профилирование

### Задание 1: [Отладка]
- **Условие**:  Вам дан JAR-файл tricky-debug.jar. Запустите его с использованием отладчика и узнайте значение переменной ans. 
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task1_condition.md)
- **Решение**: Решение не прилагается, отладка проводилась с помощью IntelliJ IDEA

### Задание 2: [Профилирование]
- **Условие**: Вам дан JAR-файл tricky-perf.jar. Запустите его с использованием профайлера. Соберите профиль хотя бы за 30 секунд работы.
В профиле вы увидите методы Trickier.step1, Trickier.step2, …, Trickier.step5. В качестве ответа укажите номера шагов, упорядоченные по возрастанию потребления процессорного времени. Например, ответ 42513 будет верным, если step4 использует меньше всего процессорного времени, а step3 — больше всего. 
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: Решение не прилагается, профилирование проводилось с помощью IntelliJ IDEA
  
---

## Лабораторная работа 6: Системы сборки

- **Условие**:  Выполните все инструкции в репозитории. После того, как workflow успешно пройдёт, мы проверим, правильно ли вы выполнили задание — это произойдёт автоматически. В таблице «Ваши решения» внизу страницы появится посылка. Убедитесь, что её статус — «Принято». 
- **Архив репозитория**:
  
---

## Лабораторная работа 7: Виртуализация и контейнеры

- **Условие**:   В этом задании вы научитесь работать с Docker. Для начала скачайте Docker Desktop (для Windows, Linux и Mac OS) или Docker Engine (для Linux), если вы этого ещё не сделали.
Мы подготовили для вас Docker-контейнер. Скачайте его: docker pull nerc.itmo.ru:32517/465265:build-8620804cbb0801ca. Используя материал лекции и документацию Docker, выполните несколько заданий. В каждом задании вам нужно будет получить ключ — строку вида {abcdef}. Её и нужно сдать в соответствующее поле.

### Задание 1: [first]
- **Условие**: Просто запустите контейнер — он выведет первый ключ в лог.
- **Решение**: `docker run -it 2a833dd39ef5`
  
### Задание 2: [args]
- **Условие**: Запустите контейнер с командой give_args_key f703e467d502b21e9369bba90b2ae720. В логе вы увидите другой ключ.
- **Решение**: `docker run 2a833dd39ef5 give_args_key f703e467d502b21e9369bba90b2ae720`

### Задание 3: [env]
- **Условие**: Запустите контейнер, передав ему переменную окружения I_NEED_KEY=341c8e90576af0652489538113c5d23c. В логе вы увидите ещё один ключ.
- **Решение**: `docker run --env I_NEED_KEY=341c8e90576af0652489538113c5d23c -it 2a833dd39ef5`

### Задание 4: [port]
- **Условие**: Запустите контейнер и пробросьте порт 32363 вашего компьютера на порт 8000 контейнера. Зайдите в браузере на http://localhost:32363, чтобы увидеть ключ.
- **Решение**: `sudo docker run -it -p 32363:8000 ae4439816a32`

### Задание 5: [volume]
- **Условие**: Создайте пустую директорию на компьютере. Запустите контейнер, примонтировав эту директорию в него по пути /place. Контейнер положит ключ в эту директорию.
- **Решение**: `sudo docker run -it -v /home/doney/Документы/CK/lab7:/place ae4439816a32`

### Задание 6: [file]
- **Условие**: Запустите контейнер. Извлеките из него файл /file.png.
- **Решение**: `sudo docker run -d --name cont ae4439816a32 tail -f /dev/null; sudo docker cp cont:/file.png ./file.png`

### Задание 7: [run]
- **Условие**: Запустите контейнер. В работающем контейнере выполните ls /var/. Ключ — название файла в директории.
- **Решение**: `sudo docker run -d --name cont ae4439816a32 tail -f /dev/null; sudo docker exec -it cont ls ./var/`

### Задание 8: [lost]
- **Условие**: Когда мы собирали контейнер, мы добавили ключ в переменную окружения LOST_KEY, но её кто-то очистил. Посмотрите, как мы собирали контейнер и найдите переменную.
- **Решение**: `sudo docker history --no-trunc ae4439816a32`

---

## Лабораторная работа 8: Отладка и профилирование

- **Условие**:   В этом задании вы научитесь работать в консольном редакторе ViM.
В этом задании вам предстоит пройти множество уровней. В каждом уровне вам необходимо исправить ошибку в файле: баг, неправильно написанное слово, лишняя строка и так далее.
Количество нажатий клавиш для исправления в каждом задании ограничено. Вверху страницы указано число уже сделанных вами нажатий и максимально доступное количество на данном уровне.
Нажмите кнопку «Уровни» вверху страницы, чтобы выбрать уровень. Когда вы исправите файл, нажмите кнопку «Проверить». Для того, чтобы начать уровень заново, нажмите кнопку «Сбросить».
Вы можете выполнять уровни в произвольном порядке. 
- **Сайт с задачками**: [ссылка на сайт с условием задания]([./lab2/task1_condition.md](https://nerc.itmo.ru/teaching/intro/vim/editor/))
- **Решение**: Решение не прилагается (тяжело воспроизвести)
  
---


## Лабораторная работа 9: Введение в базы данных

- **Условие**:    Для выполнения этого задания вам понадобится Docker и docker-compose (на Linux) или Docker Desktop (для Windows и macOS).
Скачайте и разархивируйте архив. Запустите контейнеры с базой данных и phpMyAdmin командой docker-compose up -d. Убедитесь, что на http://localhost:88 открывается phpMyAdmin.
Для каждого задания напишите SQL-запрос и сдайте его в соответствующее поле. В отправляемых запросах не нужно добавлять USE bloggle в начало.

### Задание 1: 
- **Условие**: Выведите кол-во пользователей, у кого установлен пароль (то есть passwordHash не равен NULL).
- **Решение**: `SELECT COUNT(*) FROM User WHERE passwordHash IS NOT NULL;`
  
### Задание 2: 
- **Условие**: Выведите идентификаторы авторов — пользователей, которые опубликовали хотя бы один пост. Идентификаторы отсортируйте по возрастанию.
- **Решение**: `SELECT u.id FROM User u JOIN Post p ON u.id = p.userId GROUP by u.id HAVING COUNT(p.id) > 0 ORDER BY u.id;`

### Задание 3: 
- **Условие**: Выведите таблицу со всеми постами из двух столбцов — «название поста» (postTitle) и «имя автора» (authorName). Отсортируйте данные по возрастанию времени публикации поста, а при совпадении времени — по ID поста. 
- **Решение**: `SELECT p.title AS postTitle, u.name as authorName FROM Post p JOIN User u ON p.userId = u.id ORDER BY p.creationTime, p.id;`

### Задание 4: 
- **Условие**: Для каждого автора (как в задании 2) выведите название его первого поста — поста с минимальным временем публикации, а если таких несколько — с максимальным ID. Отсортируйте список по возрастанию времени публикации, при равенстве — по убыванию ID поста. 
- **Решение**: `WITH FirstPosts AS ( SELECT p.userId, p.title, p.creationTime, p.id, ROW_NUMBER() OVER (PARTITION BY p.userId ORDER BY p.creationTime, p.id DESC) AS rn FROM Post p ) SELECT fp.title AS title FROM FirstPosts fp JOIN User u ON fp.userId = u.id WHERE fp.rn = 1 ORDER BY fp.creationTime ASC, fp.id DESC;`

### Задание 5: 
- **Условие**: Выведите все даты (не времена, а именно даты, то есть дни), в которые был опубликован хотя бы один пост. Для каждой даты выведите количество постов, опубликованных в этот день. Отсортируйте данные по возрастанию даты. 
- **Решение**: `SELECT DATE(p.creationTime) AS postCreationDate, COUNT(p.id) AS postCount FROM Post p GROUP BY postCreationDate ORDER BY postCreationDate ASC;`

### Задание 6: 
- **Условие**:  Добавьте в базу данных новую таблицу (сущность) Comment. Сущность должна быть связана с Post и User отношениями много-к-одному. У сущности должны быть столбцы id, postId, userId, text и creationTime. Используйте те же типы данных, которые используются в таблице Post. Корректно укажите внешние ключи.

Добавьте следующие комментарии в этом порядке:
postId 	userId 	text 	creationTime
5 	3 	Account word movement of face trouble me century. 	2026-04-10 11:13:04.137167
3 	1 	Pretty class attention guy. 	1987-09-06 17:26:05.528832
2 	4 	Quality easy son season add nature. 	2026-02-25 09:52:58.666515
5 	4 	Be media interesting rate. 	2010-03-03 04:35:29.118719
4 	5 	Within a professional even. 	2007-08-20 20:55:36.966110
2 	4 	Enjoy opportunity church talk mention religious. 	1980-03-30 16:20:25.786992
2 	3 	Executive specific mention heart. 	1986-08-04 19:26:24.020564
5 	4 	Piece necessary method memory. 	2008-07-12 19:45:25.031397
4 	5 	Car sit soldier provide. 	1976-12-31 18:02:24.580481

В вашем ответе сначала должны быть запросы для создания таблицы со всеми индексами, а потом запрос (или запросы) для наполнения её данными. 
- **Решение**:
```
CREATE Table Comment (
    id  bigint(20) AUTO_INCREMENT PRIMARY KEY,
    postId  bigint(20),
    userId  bigint(20),
    text longtext,
    creationTime datetime DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (postId) REFERENCES Post (id),
    FOREIGN KEY (userId) REFERENCES User (id)
);

INSERT INTO Comment (postId, userId, text) VALUES 
	(5, 3, 'Account word movement of face trouble me century.'), 
    (3, 1, 'Pretty class attention guy.'), 
    (2, 4, 'Quality easy son season add nature.'), 
    (5, 4, 'Be media interesting rate.'), 
    (4, 5, 'Within a professional even.'), 
    (2, 4, 'Enjoy opportunity church talk mention religious.'), 
    (2, 3, 'Executive specific mention heart.'), 
    (5, 4, 'Piece necessary method memory.'), 
    (4, 5, 'Car sit soldier provide.');`
```

### Задание 7: 
- **Условие**: Отсортируйте посты по убыванию количества комментариев. Выведите ID постов в этом порядке. Если количество комментариев одинаково, сначала выведите посты с меньшим ID.
- **Решение**:
```
SELECT p.id
FROM Post p
LEFT JOIN Comment c ON p.id = c.postId
GROUP BY p.id
ORDER BY COUNT(c.id) DESC, p.id;
```

  
---
