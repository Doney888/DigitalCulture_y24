# DigitalCulture_y24
Digital culture course solutions (y24 version)
**УБЕДИТЕЛЬНАЯ ПРОСЬБА**: используйте данных репозиторий только как подсказки к решению, если вы застряли на каком-то этапе, ни в коем случае не выдавайте данные решения за свои. Автор не поддерживает списывание

## Лабораторная работа 1: Работа в терминале

### Задание 1:
- **Условие**: Запустите Bash-скрипт и напишите, что выведется на экран.
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task1_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task1_solution.md)

### Задание 2: 
- **Условие**: Найдите в архиве файл с правами на исполнение. Выведите его название.
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task2_solution.md)

### Задание 3: 
- **Условие**: Посчитайте суммарное количество слов во всех файлах, имена которых содержат слово, указанное в файле target.word.
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task2_solution.md)

### Задание 4: 
- **Условие**: Отсортируйте файлы в директории по возрастанию времени модификации. Посчитайте шестнадцатеричный SHA-256 хеш конкатенации данных этих файлов в этом порядке (без каких-либо дополнительных символов).
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task2_solution.md)

### Задание 5: 
- **Условие**: 
В операционных системах семейства GNU/Linux обычно доступна специальная файловая система procfs, в которой данные о процессах представлены в виде файлов. Обычно она доступна в директории /proc.

Попробуйте зайти в неё и изучить содержимое. Каждая директория с числовым названием означает процесс с соответствующим PID. Внутри можно найти разную информацию о процессе — статистику его работы, информацию об исполняемом файле, текущей директории.

Среди них есть файл environ — в нём хранятся переменные окружения. Их используют для конфигурирования запуска или работы приложений. Нередко с их помощью передают и какие-то секреты для запуска приложения.

Вам дан архив, в котором находятся только файлы environ для каждого запущенного в системе процесса. Напишите скрипт, который найдёт лексикографически минимальное значение переменной TASK.
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task2_solution.md)

### Задание 6: 
- **Условие**: Посчитайте количество телефонных номеров в формате E.164 в данном файле. Номера могут начинаться или не начинаться со знака «+», не могут начинаться с 0 (в том числе после знака «+») и содержат от 2 до 15 цифр.

В рамках данного задания номера не могут содержать пробелы (например, +7 812 607 04 74 это три разных номера), и при этом они отделены от любых других символов хотя бы одним пробельным символом с обеих сторон. Например, в строке «(номер: +78126070474)» номера нет.

Указание: используйте регулярные выражения. 
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task2_solution.md)

### Задание 7: 
- **Условие**: [Скачайте все файлы по указанным ссылкам. Посчитайте суммарный размер PDF-документов среди скачанных файлов в байтах. Это задача с подвохом.]
- **Файл с условием**: [ссылка на файл с условием задания](./lab1/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab1/task2_solution.md)

---

## Лабораторная работа 2: Система контроля версий

### Задание 1: [master]
- **Условие**:
Первое задание - запушить коммиты которые создались когда вы написали `git start`.

Просто запустите `git verify` после того как вы начали первое задание и гордитесь что вы его выполнили :)
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task1_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task1_solution.md)

### Задание 2: [commit-one-file-staged]
- **Условие**:
  Сейчас в корне проекта есть два файла - `A.txt` и `B.txt`. Они оба были застейджены (staged for commit).
Цель - закоммитить только один из них.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 3: [ignore-them]
- **Условие**: Зачастую бывает полезно сказать гиту, за какими файлами нужно следить, а за какими нет. Разработчики почти всегда не хотят включать в историю своего проекта сгенерированные файлы, скомпилированный код или библиотеки.
Ваша задача настроить ваш репозиторий таким образом, чтобы игнорировались:
 * все файлы с расширением `exe`
 * все файлы с расширением `o`
 * все файлы с расширением `jar`
 * вся директория `libraries`
Примеры файлов уже были сгенерированы.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 4: [merge-conflict]
- **Условие**: Merge-конфликт возникает когда вы изменяете одну и ту же часть одного и того же файла по-разному
в двух ветках которые вы пытаетесь смерджить

Разработчик должен разрешать конфликты вручную.

Сейчас ваш репозиторий выглядит так:

            HEAD
             |
        merge-conflict
             |
    A <----- B
     \
      \----- C
             |
    another-piece-of-work
         
Вам нужно смерджить `another-piece-of-work` в вашу текущую ветку. 
Это создаст конфликт который вам нужно разрешить.
В конце ваш репозиторий должен выглядеть так:

                     HEAD
                      |
                 merge-conflict
                      |
    A <----- B <----- D
     \               /
      \----- C <----/
             |
    another-piece-of-work
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 5: [save-your-work]
- **Условие**: Представим ситуацию: дома вы сделали домашки по курсу "Введение в программирование": "Подсчёт слов" 
а затем домашку "Свой сканнер". Первую вы закоммитили, а вторую не доделали и не закоммитили. Вы 
приходите на пару и собираетесь записываться в очередь, как вдруг замечаете что в подсчёте слов 
сделали багу за которую вам поставят три минуса. Вам нужно быстро исправить багу и сдать домашку 
"Подсчёт слов", но текущее состояние вашего репозитория с незакоммиченными изменениями вы коммитить не хотите.

Только сейчас ситуация учебная, а не игра на баллы, поэтому вместо домашки "Подсчёт слов" у вас файл bug.txt.

Гит позволяет вам сохранить вашу работу *на стороне* и продолжить её позже. Найдите подходящий инструмент Гита и
используйте его чтобы решить ситуацию.

Ищите багу в `bug.txt`.

После того как вы закоммитили исправление баги, вернитесь к своей работе. Закончите её добавив новую строку в `bug.txt` следующего содержания:

    `Finally, finished it!`

Затем, закоммитите свою работу после исправления баги.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 6: [change-branch-history]
- **Условие**: Вы работали над обычной задачей, когда ваш босс пришел и сказал вам исправить недавний баг в приложении. Поскольку ваша
работа над задачей еще не была завершена, вы решили откатиться туда, откуда начали, и исправить баг там.

Ваш репозиторий выглядит так:

            HEAD
             |
    change-branch-history
             |
    A <----- B
     \
      \----- C
             |
         hot-bugfix
         
Теперь вы поняли, что баг вас сильно донимает, и вы не хотите продолжать свою работу без этого исправления. 
Вы хотите, чтобы ваша история выглядела так:

                     HEAD
                      |
             change-branch-history
                      |
    A <----- C <----- B
             |
         hot-bugfix

Как это сделать?
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 7: [forge-date]
- **Условие**: Вы должны были сделать домашку ещё неделю назад. Однако у вас были более
важные дела, поэтому вы сделали коммит только что.

Как эксперт по git, измените дату последнего коммита. Не стесняйтесь -
сделайте так, чтобы казалось, что он был сделан в 1987 году!

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 8: [fix-old-typo]
- **Условие**: Пока вы работали, вы заметили опечатку в `file.txt` - вы написали `wordl` вместо `world`.

К сожалению, вы сделали еще один коммит поверх опечатки, поэтому сделать `git commit --amend` недостаточно.

Исправьте опечатку, исправив коммит в истории. Так же обратите внимание на сообщение коммита.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 9: [commit-lost]
- **Условие**: Вы создали коммит с очень важными изменениями. Затем вы захотели что-то исправить в этом коммите, поэтому вы сделали ammend-коммит. После этого вы поняли, что случайно затерли важный кусок кода когда сделали ammend.

Как вам известно, `git commit --amend` затирает предыдущий коммит, поэтому вы не можете просто отменить его, так же как и не можете найти его в истории коммитов.

Ваша задача - найти первый коммит. Он же точно должен быть где-то..

После того как вы его найдете, поставьте на него ветку `commit-lost` и проверьте ваше решение с помощью `git verify`

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 10: [too-many-commits]
- **Условие**: Вы работали над задачей и создали два коммита, внесли очень маленькие изменения. Вы не хотите испортить историю своего проекта, поэтому вы хотите сделать только один коммит, который содержит изменения, сделанные в последние два.

Напишите `git log -2`, чтобы увидеть последние два коммита.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 11: [executable]
- **Условие**: Вы создали простой bash-скрипт в `script.sh`. Однако, когда вы проверяете его
в Unix, у него нет необходимых разрешений на выполнение, поэтому вы не можете запустить его с помощью
`./script.sh` без выполнения `chmod +x script.sh` заранее.

Исправьте это, добавив бит исполняемого файла для `script.sh` в историю Git.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 12: [commit-parts]
- **Условие**: Вы долгое время работаете над задачей и замечаете, что сделали слишком много. Вы хотите, чтобы ваша работа была
закоммичена в двух разных коммитах, а не одним.

К сожалению, ваши изменения касаются только одного файла, поэтому невозможно просто сделать `git add` разных файлов по отдельности.

Закоммитьте все новые строки, которые содержат фразу "Task 1" в первом коммите, а остальные во втором.

- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 13: [invalid-order]
- **Условие**: Вы сделали два коммита, но вам не нравится порядок, в котором они появляются в истории. Поменяйте его.

Чтобы показать коммиты, которые нужно поменять, выполните команду `git log -2`.
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

### Задание 14: [search-improved]
- **Условие**: В вашем репозитории содержится текстовый файл `cool-cheatsheet.txt` с полезными bash-командами.
Недавно обнаружилось, что кто-то из коллег в него дописал cтроку, после ввода которой компьютер может намертво зависнуть.

К счастью, у вас уже есть программа `faulty-check`, которая проводит исчерпывающие тесты. При запуске она возвращает код 0, если текстовый файл безопасен, и 1 иначе.

Вам нужно выяснить, в каком именно коммите появилась проблемная команда.

## Указания
 * Не нужно перебирать все коммиты, в Git есть поддержка бинарного поиска.
 * Ревизия с тегом `1.0` гарантированно не вызывает зависаний.
 * Найдя искомый коммит, проверить решение можно при помощи следующей команды
 
        git push origin COMMIT_ID:search-improved
- **Файл с условием**: [ссылка на файл с условием задания](./lab2/task2_condition.md)
- **Решение**: [ссылка на файл с решением задания](./lab2/task2_solution.md)

---
